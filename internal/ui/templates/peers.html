<!-- internal/ui/templates/peers.html -->
{{define "page.peers"}}
<div class="peers-page">
  <div class="peers-panel">
    <div class="peers-section">
      <h1>Peers <span class="peer-count muted" id="peer-count">({{len .Peers}})</span></h1>

      <input type="text" id="peer-search" class="peer-search" placeholder="Search peers..." autocomplete="off">

      <div id="peers-list" class="peers-list-scroll">
      {{if not .Peers}}
        <p class="muted"><i>No peers yet</i></p>
      {{else}}
      <ul class="peers">
        {{range .Peers}}
        <li class="peerrow" data-peer-id="{{.ID}}">
          <img class="avatar avatar-md" src="/api/avatar/peer/{{.ID}}" alt="">
          <div class="peerleft">
            <div class="peer-name-row">
              <a class="peerid" href="/peer/{{.ID}}">
                <span class="peer-badge" data-unread-badge="{{.ID}}" style="display:none;">‚óè</span>
                {{if .Content}}{{.Content}}{{else}}{{shortID .ID}}{{end}}
              </a>
              {{if .Email}}<span class="peeremail muted small">{{.Email}}</span>{{end}}
            </div>
            <span class="peercontent muted small"><code>{{shortID .ID}}</code> &middot; seen {{rfc3339 .LastSeen}}</span>
          </div>
          <div class="peerright">
            <a class="btn"
               href="{{printf "%s/p/%s/" $.BaseURL .ID}}"
               onclick="return openExternal(this.href)"
               rel="noopener">
              Open Site
            </a>
          </div>
        </li>
        {{end}}
      </ul>
      {{end}}
      </div>
    </div>

    <div class="broadcast-section">
      <h2>üì¢ Broadcast Chat</h2>
      <p class="muted small">Messages sent here are visible to all connected peers</p>

      <div class="chat-container">
        <div class="chat-messages" id="broadcast-messages">
          <p class="muted"><i>Loading messages...</i></p>
        </div>
        <form class="chat-input" id="broadcast-form">
          <input type="text" id="broadcast-input" placeholder="Broadcast to all peers..." autocomplete="off" required>
          <button type="submit">Send</button>
        </form>
      </div>
    </div>
  </div>

  <div class="peers-splash">
    <img src="/assets/images/goop2-splash.png" alt="Goop¬≤">
  </div>
</div>

<script>
(function() {
  const selfID = '{{.SelfID}}';
  const selfName = '{{.SelfName}}';
  const peersList = document.getElementById('peers-list');
  const peerCount = document.getElementById('peer-count');
  const peerSearch = document.getElementById('peer-search');
  const messagesDiv = document.getElementById('broadcast-messages');
  const form = document.getElementById('broadcast-form');
  const input = document.getElementById('broadcast-input');

  // Track unread direct messages per peer
  const unreadPeers = new Set();

  // Current peers data for search filtering
  let currentPeers = [];

  // Map of peer ID -> friendly label
  const peerLabels = {
    [selfID]: selfName || 'Me'
  };

  // Initialize labels from server-rendered peers
  {{range .Peers}}
  peerLabels['{{.ID}}'] = '{{.Content}}' || '{{shortID .ID}}';
  {{end}}

  // =====================
  // Peers List Auto-Refresh
  // =====================

  function renderPeerRow(peer) {
    const shortId = peer.ID.substring(0, 8) + '...';
    const lastSeen = new Date(peer.LastSeen).toISOString();
    const hasUnread = unreadPeers.has(peer.ID);

    var avatarSrc = '/api/avatar/peer/' + encodeURIComponent(peer.ID);
    if (peer.AvatarHash) avatarSrc += '?v=' + encodeURIComponent(peer.AvatarHash);

    var peerName = peer.Content || shortId;

    return `<li class="peerrow" data-peer-id="${escapeHtml(peer.ID)}">
      <img class="avatar avatar-md" src="${avatarSrc}" alt="">
      <div class="peerleft">
        <div class="peer-name-row">
          <a class="peerid" href="/peer/${escapeHtml(peer.ID)}">
            <span class="peer-badge" data-unread-badge="${escapeHtml(peer.ID)}" style="display:${hasUnread ? 'inline' : 'none'};">‚óè</span>
            ${escapeHtml(peerName)}
          </a>
          ${peer.Email ? '<span class="peeremail muted small">' + escapeHtml(peer.Email) + '</span>' : ''}
        </div>
        <span class="peercontent muted small"><code>${escapeHtml(shortId)}</code> &middot; seen ${escapeHtml(lastSeen)}</span>
      </div>
      <div class="peerright">
        <a class="btn" href="{{.BaseURL}}/p/${peer.ID}/" onclick="return openExternal(this.href)" rel="noopener">
          Open Site
        </a>
      </div>
    </li>`;
  }

  function renderPeersList(peers) {
    if (peers) {
      currentPeers = peers;
      // Update peer labels map
      peers.forEach(peer => {
        peerLabels[peer.ID] = peer.Content || peer.ID.substring(0, 8) + '...';
      });
      peerCount.textContent = '(' + peers.length + ')';
    }

    // Apply search filter
    const query = (peerSearch.value || '').trim().toLowerCase();
    let filtered = currentPeers;
    if (query) {
      filtered = currentPeers.filter(peer => {
        const name = (peer.Content || '').toLowerCase();
        const id = peer.ID.toLowerCase();
        return name.includes(query) || id.includes(query);
      });
    }

    if (!filtered || filtered.length === 0) {
      if (query && currentPeers.length > 0) {
        peersList.innerHTML = '<p class="muted"><i>No peers match "' + escapeHtml(query) + '"</i></p>';
      } else {
        peersList.innerHTML = '<p class="muted"><i>No peers yet</i></p>';
      }
      return;
    }

    peersList.innerHTML = '<ul class="peers">' + filtered.map(renderPeerRow).join('') + '</ul>';

    // Re-attach click handlers for clearing badges
    document.querySelectorAll('.peerrow').forEach(row => {
      const peerID = row.getAttribute('data-peer-id');
      row.addEventListener('click', () => {
        unreadPeers.delete(peerID);
        const badge = document.querySelector('[data-unread-badge="' + peerID + '"]');
        if (badge) badge.style.display = 'none';
      });
    });
  }

  // Wire up search
  peerSearch.addEventListener('input', () => {
    renderPeersList(null);
  });

  // Connect to peers SSE
  const peersSSE = new EventSource('/api/peers/events');

  peersSSE.addEventListener('snapshot', (e) => {
    try {
      const data = JSON.parse(e.data);
      if (data.peers) renderPeersList(data.peers);
    } catch (err) {
      console.error('Failed to parse peers snapshot:', err);
    }
  });

  peersSSE.addEventListener('update', (e) => {
    // Peer added or updated - refresh list via API for simplicity
    fetch('/api/peers').then(r => r.json()).then(renderPeersList).catch(console.error);
  });

  peersSSE.addEventListener('remove', (e) => {
    // Peer removed - refresh list via API for simplicity
    fetch('/api/peers').then(r => r.json()).then(renderPeersList).catch(console.error);
  });

  peersSSE.onerror = () => {
    console.error('Peers SSE connection lost');
  };

  // =====================
  // Broadcast Chat
  // =====================

  async function loadBroadcasts() {
    try {
      const res = await fetch('/api/chat/broadcasts');
      const messages = await res.json();
      renderBroadcasts(messages);
    } catch (err) {
      console.error('Failed to load broadcasts:', err);
      messagesDiv.innerHTML = '<p class="error">Failed to load messages</p>';
    }
  }

  function renderBroadcasts(messages) {
    if (!messages || messages.length === 0) {
      messagesDiv.innerHTML = '<p class="muted"><i>No broadcast messages yet. Say hello!</i></p>';
      return;
    }

    messagesDiv.innerHTML = messages.map(msg => {
      const time = new Date(msg.timestamp).toLocaleString();
      const isOutgoing = msg.from === selfID;
      const className = isOutgoing ? 'msg-out' : 'msg-in';
      const senderName = peerLabels[msg.from] || msg.from.substring(0, 8) + '...';
      const avatarUrl = isOutgoing
        ? '/api/avatar'
        : '/api/avatar/peer/' + encodeURIComponent(msg.from);

      return `<div class="chat-msg ${className}">
        <img class="avatar avatar-xs chat-msg-avatar" src="${avatarUrl}" alt="">
        <div class="chat-msg-body">
          <div class="msg-sender">${escapeHtml(senderName)}</div>
          <div class="msg-content">${escapeHtml(msg.content)}</div>
          <div class="msg-time">${time}</div>
        </div>
      </div>`;
    }).join('');

    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  // Send broadcast
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const content = input.value.trim();
    if (!content) return;

    try {
      const res = await fetch('/api/chat/broadcast', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      });

      if (res.ok) {
        input.value = '';
        loadBroadcasts();
      } else {
        alert('Failed to send broadcast');
      }
    } catch (err) {
      console.error('Failed to send:', err);
      alert('Failed to send broadcast');
    }
  });

  // Listen for new messages via SSE (both direct and broadcast)
  const chatSSE = new EventSource('/api/chat/events');

  chatSSE.addEventListener('message', (e) => {
    try {
      const msg = JSON.parse(e.data);
      const msgType = msg.type || 'direct';

      if (msgType === 'broadcast') {
        // Reload broadcasts
        loadBroadcasts();
      } else if (msgType === 'direct' && msg.from && msg.from !== selfID) {
        // Mark peer as having unread direct messages
        unreadPeers.add(msg.from);
        const badge = document.querySelector('[data-unread-badge="' + msg.from + '"]');
        if (badge) badge.style.display = 'inline';
      }
    } catch (err) {
      console.error('Failed to parse message:', err);
    }
  });

  chatSSE.onerror = () => {
    console.error('Chat SSE connection lost');
  };

  var escapeHtml = window.Goop && window.Goop.core ? window.Goop.core.escapeHtml : function(text) {
    if (!text) return '';
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  };

  // Initial load
  loadBroadcasts();
})();
</script>
{{end}}
