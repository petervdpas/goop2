{{define "page.peers"}}
<div class="peers-page">
  <div class="peers-panel">
    <div class="peers-section">
      <h1>Peers <span class="peer-count muted" id="peer-count">({{len .Peers}})</span></h1>

      <input type="text" id="peer-search" class="peer-search" placeholder="Search peers..." autocomplete="off">

      <div id="peers-list" class="peers-list-scroll">
      {{if not .Peers}}
        <p class="muted"><i>No peers yet</i></p>
      {{else}}
      <ul class="peers">
        {{range .Peers}}
        <li class="peerrow" data-peer-id="{{.ID}}">
          <img class="avatar avatar-md" src="/api/avatar/peer/{{.ID}}" alt="">
          <div class="peerleft">
            <div class="peer-name-row">
              <a class="peerid" href="/peer/{{.ID}}">
                <span class="peer-badge" data-unread-badge="{{.ID}}" style="display:none;">‚óè</span>
                {{if .Content}}{{.Content}}{{else}}{{shortID .ID}}{{end}}
              </a>
              {{if .ActiveTemplate}}<span class="peer-template-badge">{{.ActiveTemplate}}</span>{{end}}
              {{if not .Verified}}<span class="badge-unverified">unverified</span>{{end}}
              {{if .Email}}<span class="peeremail muted small">{{.Email}}</span>{{end}}
            </div>
            <span class="peercontent muted small"><code>{{shortID .ID}}</code> &middot; seen {{rfc3339 .LastSeen}}</span>
          </div>
          <div class="peerright">
            {{if or .VideoDisabled $.SelfVideoDisabled}}
            <span class="peer-video-disabled" title="Video/audio calls disabled">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color:#f39c12;">
                <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>
              </svg>
            </span>
            {{else}}
            <button class="peer-call-btn" data-call-audio="{{.ID}}" title="Voice call">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72c.12.8.3 1.58.52 2.34a2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45c.76.22 1.54.4 2.34.52A2 2 0 0 1 22 16.92z"/>
              </svg>
            </button>
            <button class="peer-call-btn" data-call-video="{{.ID}}" title="Video call">
              <svg width="16" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="23 7 16 12 23 17 23 7"/>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
              </svg>
            </button>
            {{end}}
            <a class="btn"
               href="{{printf "%s/p/%s/" $.BaseURL .ID}}"
               onclick="return openExternal(this.href)"
               rel="noopener">
              Open Site
            </a>
          </div>
        </li>
        {{end}}
      </ul>
      {{end}}
      </div>
    </div>

    <div class="broadcast-section">
      <h2>üì¢ Broadcast Chat</h2>
      <p class="muted small">Messages sent here are visible to all connected peers</p>

      <div class="chat-container">
        <div class="chat-messages" id="broadcast-messages">
          <p class="muted"><i>Loading messages...</i></p>
        </div>
        <form class="chat-input" id="broadcast-form">
          <input type="text" id="broadcast-input" placeholder="Broadcast to all peers..." autocomplete="off" required>
          <button type="submit">Send</button>
        </form>
      </div>
    </div>
  </div>

  <div class="peers-splash">
    <img src="/assets/images/goop2-splash.png" alt="Goop¬≤">
  </div>
</div>

<script>
(function() {
  const selfID = '{{.SelfID}}';
  const selfName = '{{.SelfName}}';
  const selfVideoDisabled = {{.SelfVideoDisabled}};
  const hideUnverified = {{.HideUnverified}};
  const peersList = document.getElementById('peers-list');
  const peerCount = document.getElementById('peer-count');
  const peerSearch = document.getElementById('peer-search');
  const messagesDiv = document.getElementById('broadcast-messages');
  const form = document.getElementById('broadcast-form');
  const input = document.getElementById('broadcast-input');

  // Track unread direct messages per peer
  const unreadPeers = new Set();

  // Current peers data for search filtering
  let currentPeers = [];

  // Map of peer ID -> friendly label
  const peerLabels = {
    [selfID]: selfName || 'Me'
  };

  // Initialize labels from server-rendered peers
  {{range .Peers}}
  peerLabels['{{.ID}}'] = '{{.Content}}' || '{{shortID .ID}}';
  {{end}}

  // =====================
  // Peers List Auto-Refresh
  // =====================

  function renderPeerRow(peer) {
    const shortId = peer.ID.substring(0, 8) + '...';
    const lastSeen = new Date(peer.LastSeen).toISOString();
    const hasUnread = unreadPeers.has(peer.ID);

    var avatarSrc = '/api/avatar/peer/' + encodeURIComponent(peer.ID);
    if (peer.AvatarHash) avatarSrc += '?v=' + encodeURIComponent(peer.AvatarHash);

    var peerName = peer.Content || shortId;

    return `<li class="peerrow" data-peer-id="${escapeHtml(peer.ID)}">
      <img class="avatar avatar-md" src="${avatarSrc}" alt="">
      <div class="peerleft">
        <div class="peer-name-row">
          <a class="peerid" href="/peer/${escapeHtml(peer.ID)}">
            <span class="peer-badge" data-unread-badge="${escapeHtml(peer.ID)}" style="display:${hasUnread ? 'inline' : 'none'};">‚óè</span>
            ${escapeHtml(peerName)}
          </a>
          ${peer.ActiveTemplate ? '<span class="peer-template-badge">' + escapeHtml(peer.ActiveTemplate) + '</span>' : ''}
          ${peer.Verified ? '' : '<span class="badge-unverified">unverified</span>'}
          ${peer.Email ? '<span class="peeremail muted small">' + escapeHtml(peer.Email) + '</span>' : ''}
        </div>
        <span class="peercontent muted small"><code>${escapeHtml(shortId)}</code> &middot; seen ${escapeHtml(lastSeen)}</span>
      </div>
      <div class="peerright">
        ${(peer.VideoDisabled || selfVideoDisabled) ? `
        <span class="peer-video-disabled" title="Video/audio calls disabled">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color:#f39c12;">
            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>
          </svg>
        </span>
        ` : `
        <button class="peer-call-btn" data-call-audio="${escapeHtml(peer.ID)}" title="Voice call">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72c.12.8.3 1.58.52 2.34a2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45c.76.22 1.54.4 2.34.52A2 2 0 0 1 22 16.92z"/>
          </svg>
        </button>
        <button class="peer-call-btn" data-call-video="${escapeHtml(peer.ID)}" title="Video call">
          <svg width="16" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="23 7 16 12 23 17 23 7"/>
            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
          </svg>
        </button>
        `}
        <a class="btn" href="{{.BaseURL}}/p/${peer.ID}/" onclick="return openExternal(this.href)" rel="noopener">
          Open Site
        </a>
      </div>
    </li>`;
  }

  function renderPeersList(peers) {
    if (peers) {
      currentPeers = peers;
      // Update peer labels map
      peers.forEach(peer => {
        peerLabels[peer.ID] = peer.Content || peer.ID.substring(0, 8) + '...';
      });
      peerCount.textContent = '(' + peers.length + ')';
    }

    // Apply search filter
    const query = (peerSearch.value || '').trim().toLowerCase();
    let filtered = currentPeers;
    if (hideUnverified) {
      filtered = filtered.filter(peer => peer.Verified);
    }
    if (query) {
      filtered = filtered.filter(peer => {
        const name = (peer.Content || '').toLowerCase();
        const id = peer.ID.toLowerCase();
        return name.includes(query) || id.includes(query);
      });
    }

    if (!filtered || filtered.length === 0) {
      if (query && currentPeers.length > 0) {
        peersList.innerHTML = '<p class="muted"><i>No peers match "' + escapeHtml(query) + '"</i></p>';
      } else {
        peersList.innerHTML = '<p class="muted"><i>No peers yet</i></p>';
      }
      return;
    }

    peersList.innerHTML = '<ul class="peers">' + filtered.map(renderPeerRow).join('') + '</ul>';

    // Re-attach click handlers for clearing badges
    document.querySelectorAll('.peerrow').forEach(row => {
      const peerID = row.getAttribute('data-peer-id');
      row.addEventListener('click', () => {
        unreadPeers.delete(peerID);
        const badge = document.querySelector('[data-unread-badge="' + peerID + '"]');
        if (badge) badge.style.display = 'none';
      });
    });

    // Attach call button handlers + update busy state
    attachCallButtons();
  }

  // Wire up search
  peerSearch.addEventListener('input', () => {
    renderPeersList(null);
  });

  // Connect to peers SSE
  const peersSSE = new EventSource('/api/peers/events');

  peersSSE.addEventListener('snapshot', (e) => {
    try {
      const data = JSON.parse(e.data);
      if (data.peers) renderPeersList(data.peers);
    } catch (err) {
      console.error('Failed to parse peers snapshot:', err);
    }
  });

  peersSSE.addEventListener('update', (e) => {
    // Peer added or updated - refresh list via API for simplicity
    fetch('/api/peers').then(r => r.json()).then(renderPeersList).catch(console.error);
  });

  peersSSE.addEventListener('remove', (e) => {
    // Peer removed - refresh list via API for simplicity
    fetch('/api/peers').then(r => r.json()).then(renderPeersList).catch(console.error);
  });

  peersSSE.onerror = () => {
    console.error('Peers SSE connection lost');
  };

  // =====================
  // Call Buttons
  // =====================

  // Track peers that are in active calls
  const busyPeers = new Set();

  function attachCallButtons() {
    // Disable buttons for busy peers
    document.querySelectorAll('.peer-call-btn').forEach(btn => {
      const audioId = btn.getAttribute('data-call-audio');
      const videoId = btn.getAttribute('data-call-video');
      const peerId = audioId || videoId;
      if (peerId && busyPeers.has(peerId)) {
        btn.disabled = true;
        btn.classList.add('busy');
        btn.title = 'In a call';
      }
    });

    // Audio call buttons
    document.querySelectorAll('[data-call-audio]').forEach(btn => {
      btn.onclick = function(e) {
        e.stopPropagation();
        var pid = btn.getAttribute('data-call-audio');
        startPeerCall(pid, { audio: true, video: false });
      };
    });

    // Video call buttons
    document.querySelectorAll('[data-call-video]').forEach(btn => {
      btn.onclick = function(e) {
        e.stopPropagation();
        var pid = btn.getAttribute('data-call-video');
        startPeerCall(pid, { audio: true, video: true });
      };
    });
  }

  function startPeerCall(peerId, constraints) {
    if (!window.Goop || !window.Goop.callUI) {
      alert('Call feature not available');
      return;
    }
    if (busyPeers.has(peerId)) return;

    busyPeers.add(peerId);
    updateBusyState();

    Goop.callUI.startCall(peerId, constraints).then(function(session) {
      session.onHangup(function() {
        busyPeers.delete(peerId);
        updateBusyState();
      });
    }).catch(function(err) {
      console.error('Call failed:', err);
      busyPeers.delete(peerId);
      updateBusyState();
    });
  }

  function updateBusyState() {
    document.querySelectorAll('.peer-call-btn').forEach(btn => {
      var audioId = btn.getAttribute('data-call-audio');
      var videoId = btn.getAttribute('data-call-video');
      var peerId = audioId || videoId;
      if (!peerId) return;

      if (busyPeers.has(peerId)) {
        btn.disabled = true;
        btn.classList.add('busy');
        btn.title = 'In a call';
      } else {
        btn.disabled = false;
        btn.classList.remove('busy');
        btn.title = audioId ? 'Voice call' : 'Video call';
      }
    });
  }

  // Attach handlers for server-rendered rows
  attachCallButtons();

  // =====================
  // Broadcast Chat
  // =====================

  async function loadBroadcasts() {
    try {
      const res = await fetch('/api/chat/broadcasts');
      const messages = await res.json();
      renderBroadcasts(messages);
    } catch (err) {
      console.error('Failed to load broadcasts:', err);
      messagesDiv.innerHTML = '<p class="error">Failed to load messages</p>';
    }
  }

  function renderBroadcasts(messages) {
    if (!messages || messages.length === 0) {
      messagesDiv.innerHTML = '<p class="muted"><i>No broadcast messages yet. Say hello!</i></p>';
      return;
    }

    messagesDiv.innerHTML = messages.map(msg => {
      const time = new Date(msg.timestamp).toLocaleString();
      const isOutgoing = msg.from === selfID;
      const className = isOutgoing ? 'msg-out' : 'msg-in';
      const senderName = peerLabels[msg.from] || msg.from.substring(0, 8) + '...';
      const avatarUrl = isOutgoing
        ? '/api/avatar'
        : '/api/avatar/peer/' + encodeURIComponent(msg.from);

      return `<div class="chat-msg ${className}">
        <img class="avatar avatar-xs chat-msg-avatar" src="${avatarUrl}" alt="">
        <div class="chat-msg-body">
          <div class="msg-sender">${escapeHtml(senderName)}</div>
          <div class="msg-content">${escapeHtml(msg.content)}</div>
          <div class="msg-time">${time}</div>
        </div>
      </div>`;
    }).join('');

    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  // Send broadcast
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const content = input.value.trim();
    if (!content) return;

    try {
      const res = await fetch('/api/chat/broadcast', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      });

      if (res.ok) {
        input.value = '';
        loadBroadcasts();
      } else {
        alert('Failed to send broadcast');
      }
    } catch (err) {
      console.error('Failed to send:', err);
      alert('Failed to send broadcast');
    }
  });

  // Listen for new messages via SSE (both direct and broadcast)
  const chatSSE = new EventSource('/api/chat/events');

  chatSSE.addEventListener('message', (e) => {
    try {
      const msg = JSON.parse(e.data);
      const msgType = msg.type || 'direct';

      if (msgType === 'broadcast') {
        // Reload broadcasts
        loadBroadcasts();
      } else if (msgType === 'direct' && msg.from && msg.from !== selfID) {
        // Mark peer as having unread direct messages
        unreadPeers.add(msg.from);
        const badge = document.querySelector('[data-unread-badge="' + msg.from + '"]');
        if (badge) badge.style.display = 'inline';
      }
    } catch (err) {
      console.error('Failed to parse message:', err);
    }
  });

  chatSSE.onerror = () => {
    console.error('Chat SSE connection lost');
  };

  var escapeHtml = window.Goop && window.Goop.core ? window.Goop.core.escapeHtml : function(text) {
    if (!text) return '';
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  };

  // Initial load
  loadBroadcasts();
})();
</script>
{{end}}
