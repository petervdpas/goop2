<!-- internal/rendezvous/assets/index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{.Title}}</title>
  <link rel="stylesheet" href="/assets/style.css" />
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-left">
        <div class="logo">üì°</div>
        <div>
          <h1>Goop¬≤ Rendezvous Monitor</h1>
          <p class="subtitle">Live peer tracking dashboard ¬∑ ephemeral web</p>
        </div>
      </div>
      <div class="header-right">
        <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
          <span class="theme-icon">üåô</span>
        </button>
        <a class="api-link" href="/peers.json" target="_blank">üìÑ API</a>
        <a class="api-link" href="/healthz" target="_blank">‚úì Health</a>
      </div>
    </header>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Server Endpoint</div>
        <div class="stat-value">{{.Endpoint}}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Connected Peers</div>
        <div class="stat-value" id="count">{{.PeerCount}}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Last Updated</div>
        <div class="stat-value small-text">{{.Now}}</div>
      </div>
    </div>

    <div class="search-bar">
      <span class="search-icon">üîç</span>
      <input id="q" class="search-input" placeholder="Filter by peer ID or label..." />
    </div>

    <div class="tabs">
      <button class="tab-button active" data-tab="peers">üì° Active Peers</button>
      <button class="tab-button" data-tab="logs">üìã Server Logs</button>
    </div>

    <div class="tab-content active" id="peers-tab">
      <div class="peers-section">
        <h2 class="section-title">Active Peers</h2>

        <div id="peers-container">
          {{if eq (len .Peers) 0}}
            <div class="empty-state" id="empty-state">
              <div class="empty-icon">üì≠</div>
              <p>No peers connected yet</p>
              <p class="empty-hint">Peers will appear here once they connect to the rendezvous server</p>
            </div>
          {{else}}
            <div class="peer-grid" id="peer-grid">
              {{range .Peers}}
                <div class="peer-card peer-row" data-status="{{statusClass .Type}}">
                  <div class="peer-header">
                    <span class="status-badge {{statusClass .Type}}">{{.Type}}</span>
                    <span class="peer-time">{{fmtMillis .LastSeen}}</span>
                  </div>
                  <div class="peer-label">{{.Content}}</div>
                  {{if .Email}}<div class="peer-email">{{.Email}}</div>{{end}}
                  <div class="peer-id">{{.PeerID}}</div>
                  <div class="peer-stats">
                    <span class="stat-item" title="Data sent by peer">‚Üë {{fmtBytes .BytesSent}}</span>
                    <span class="stat-item" title="Data received by peer">‚Üì {{fmtBytes .BytesReceived}}</span>
                  </div>
                </div>
              {{end}}
            </div>
          {{end}}
        </div>
      </div>
    </div>

    <div class="tab-content" id="logs-tab">
      <div class="logs-section">
        <h2 class="section-title">Server Logs</h2>
        <div class="logs-container" id="logs-container">
          <div class="log-entry">Loading logs...</div>
        </div>
      </div>
    </div>

    <script>
      // Format bytes helper
      function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
      }

      // Theme toggle
      (function(){
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = themeToggle.querySelector('.theme-icon');
        const html = document.documentElement;
        
        // Load saved theme
        const savedTheme = localStorage.getItem('theme') || 'dark';
        html.setAttribute('data-theme', savedTheme);
        themeIcon.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        themeToggle.addEventListener('click', function() {
          const currentTheme = html.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          html.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
          themeIcon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        });
      })();
      
      // Tab switching
      (function(){
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabButtons.forEach(button => {
          button.addEventListener('click', function() {
            const targetTab = this.getAttribute('data-tab');
            
            // Update buttons
            tabButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            
            // Update content
            tabContents.forEach(content => {
              content.classList.remove('active');
            });
            document.getElementById(`${targetTab}-tab`).classList.add('active');
            
            // If switching to logs, refresh immediately
            if (targetTab === 'logs') {
              updateLogs();
            }
          });
        });
      })();
      
      // Auto-refresh via AJAX (no page flash)
      (function(){
        var REFRESH_MS = 2000;

        async function updatePeers() {
          if (document.hidden) return;
          var q = document.getElementById('q');
          if (q && q === document.activeElement) return;

          try {
            const response = await fetch('/peers.json');
            const data = await response.json();

            // Update peer count
            const countEl = document.getElementById('count');
            if (countEl) countEl.textContent = data.length;

            // Get the container (always exists)
            const container = document.getElementById('peers-container');
            if (!container) return;

            if (data.length === 0) {
              // Show empty state
              container.innerHTML = `
                <div class="empty-state" id="empty-state">
                  <div class="empty-icon">üì≠</div>
                  <p>No peers connected yet</p>
                  <p class="empty-hint">Peers will appear here once they connect to the rendezvous server</p>
                </div>
              `;
              return;
            }

            // Build new peer cards HTML
            const html = data.map(peer => {
              const statusClass = peer.type === 'online' ? 'on' : (peer.type === 'offline' ? 'off' : 'up');
              const lastSeen = peer.last_seen ? new Date(peer.last_seen).toLocaleString() : '';
              const bytesSent = formatBytes(peer.bytes_sent || 0);
              const bytesRecv = formatBytes(peer.bytes_received || 0);
              return `
                <div class="peer-card peer-row" data-status="${statusClass}">
                  <div class="peer-header">
                    <span class="status-badge ${statusClass}">${peer.type}</span>
                    <span class="peer-time">${lastSeen}</span>
                  </div>
                  <div class="peer-label">${peer.content || 'Unknown'}</div>
                  ${peer.email ? '<div class="peer-email">' + peer.email + '</div>' : ''}
                  <div class="peer-id">${peer.peer_id}</div>
                  <div class="peer-stats">
                    <span class="stat-item" title="Data sent by peer">‚Üë ${bytesSent}</span>
                    <span class="stat-item" title="Data received by peer">‚Üì ${bytesRecv}</span>
                  </div>
                </div>
              `;
            }).join('');

            // Wrap in peer-grid div
            container.innerHTML = '<div class="peer-grid" id="peer-grid">' + html + '</div>';

            // Reapply filter
            applyFilter();
          } catch (err) {
            console.error('Failed to update peers:', err);
          }
        }

        setInterval(updatePeers, REFRESH_MS);

        async function updateLogs() {
          try {
            const response = await fetch('/logs.json');
            const logs = await response.json();

            const logsContainer = document.getElementById('logs-container');
            if (!logsContainer) return;

            if (logs.length === 0) {
              logsContainer.innerHTML = '<div class="log-entry empty">No logs yet</div>';
              return;
            }

            // Reverse to show newest first (descending order)
            const html = logs.reverse().map(log => `<div class="log-entry">${log}</div>`).join('');
            logsContainer.innerHTML = html;
          } catch (err) {
            console.error('Failed to fetch logs:', err);
          }
        }

        setInterval(updateLogs, REFRESH_MS);
        updateLogs(); // Initial load

        var q = document.getElementById('q');

        function applyFilter(){
          var v = (q.value || '').toLowerCase().trim();
          var container = document.getElementById('peers-container');
          if (!container) return;
          var rows = container.querySelectorAll('.peer-row');
          var shown = 0;
          rows.forEach(function(tr){
            var t = tr.textContent.toLowerCase();
            var ok = !v || t.indexOf(v) !== -1;
            tr.style.display = ok ? '' : 'none';
            if (ok) shown++;
          });
          document.getElementById('count').textContent = shown;
        }
        
        window.applyFilter = applyFilter;
        q.addEventListener('input', applyFilter);
        applyFilter();
      })();
    </script>
  </div>
</body>
</html>
